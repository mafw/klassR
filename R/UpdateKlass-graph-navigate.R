#' Given a Klass graph, find the node corresponding to a code and (optionally) a
#' date.
#'
#' @param graph A graph generated by \code{\link{KlassGraph}}.
#' @param x The code to search for.
#' @param date Optional. The specific date the supplied code is valid in.
#'
#' @return The node in the graph corresponding to the supplied code. If date is
#'   not provided, the node with the most recent code is returned. If date is
#'   provided, the code with date between \code{validFrom} and \code{validTo} is
#'   returned.
#' @export
#'
#' @examples
#' 
#' # Build a graph directed towards the most recent codes.
#'
#' klass_131 <- KlassGraph(131)
#'
#' # Find the most recent node in the graph representing the code "0101" (Halden,
#' # valid to 2020.)
#'
#' halden_node <- KlassNode(klass_131, "0101")
#' 
KlassNode <- function(graph, x, date = NULL) {
  
  if (!is.null(date)) {
    
    date <- as.Date(date[[1]])
    
    node <- V(graph)[code == x & date >= validFrom & (date < validTo | is.na(validTo))]
    
  } else {
    
    node <- V(graph)[code == x][variant == max(variant)]
    
  }
  
  if (length(node) == 1) {
    
    return(node)
    
  } else if (length(node) > 1) {
    
    stop("More than one node found.")
    
  } else {
    
    stop("Found no nodes.")
  }
  
}

#' Count the neighbors of a node.
#'
#' @inheritParams UpdateKlassNode
#' @inheritParams igraph::neighbors
#'
#' @return A numeric vector of length one giving the number of neighbors.
#'
count_neighbors <- function(graph, node, mode) {
  
  length(igraph::neighbors(graph, node, mode))
  
}

#' Given a graph and a node, determine if the node is a split code.
#'
#' @inheritParams UpdateKlassNode
#'
#' @return \code{TRUE} if the node is split, otherwise \code{FALSE}.
#'
#' @details The function will attempt to reconcile nodes that have split and
#'   then later merged again. A node is considered to be split if there is more
#'   than one node that does not itself have children (i.e. nodes at the end of
#'   a sequence of changes) that can be reached from \code{node}
#'
is_split <- function(graph, node) {
  
  bfs_result <- igraph::bfs(graph = graph, 
                            root = node, 
                            mode = "out", 
                            unreachable = FALSE)
  
  end_nodes <- bfs_result$order[map_dbl(.x = bfs_result$order, 
                                        .f = count_neighbors,
                                        graph = graph,
                                        mode = "out") == 0]
  
  length(unique(end_nodes)) > 1
  
}

#' Given a graph and a node, determine if the node is a result of combinations
#' of multiple codes
#'
#' @inheritParams UpdateKlassNode
#'
#' @param compare_node Optional. A node to compare \code{node} with when
#'   determining whether \code{node} is combined. See details.
#'
#' @return \code{TRUE} if the node is a combination of two or more nodes,
#'   otherwise \code{FALSE}.
#'
#' @details The function will attempt to reconcile nodes that have split and
#'   then later merged again when evaluating a node's combinedness.
#'
#'   If \code{compare_node == NULL}, a node is considered to be combined if more
#'   than one node that does not itself have a parent (i.e. codes at the start
#'   of a sequence of changes) contribute to \code{node}.
#'
#'   If \code{compare_node != NULL}, a node is considered to be combined if any
#'   node that is not an ancestor of \code{compare_node} contributes to
#'   \code{node}, i.e. all paths from \code{node} to the parents of \code{node}
#'   pass through \code{compare_node}.
#'
#' 
is_combined <- function(graph, node, compare_node = NULL) {
  
  bfs_result <- igraph::bfs(graph = graph, 
                            root = node, 
                            mode = "in", 
                            unreachable = FALSE)
  
  start_nodes <- bfs_result$order[map_dbl(.x = bfs_result$order, 
                                          .f = count_neighbors,
                                          graph = graph,
                                          mode = "in") == 0]
  
  if (is.null(compare_node)) {
    
    length(unique(start_nodes)) > 1
    
  } else {
    
    paths <- all_simple_paths(graph, node, start_nodes, mode = "in")
    
    return(!all(map_lgl(paths, \(path) compare_node %in% path)))
    
  }
  
}

#' Given a node and a graph, find the node at the end of a sequence of changes.
#'
#' @inheritParams KlassNode
#' @param node A node as returned by \code{\link{KlassNode}} or \code{\link[igraph]{V}}.
#'
#' @param combine Allow nodes to be combined? If \code{FALSE}, the node search will
#'   halt if the visited node is a combination of multiple nodes.
#'
#' @return A sequence of vertices, starting with \code{node} and ending with the last
#'   visited node.
#'   
#' @export
#'   
#' @examples
#' 
#' # Build a graph directed towards the most recent codes.
#'
#' klass_131 <- KlassGraph(131)
#'
#' # Find the most recent node in the graph representing the code "0101" (Halden,
#' # valid to 2020.)
#'
#' halden_node <- KlassNode(klass_131, "0101")
#' 
#' # Find the most recent code corresponding to 0101 Halden
#' 
#' halden_node_updated <- UpdateKlassNode(klass_131, halden_node)
#' 
#' 
UpdateKlassNode <- function(graph, node, combine = TRUE) {
  
  bfs_result <- igraph::bfs(graph = graph, 
                            root = node, 
                            mode = "out", 
                            unreachable = FALSE)
  
  
  end_nodes <- bfs_result$order[map_dbl(.x = bfs_result$order, 
                                        .f = count_neighbors,
                                        graph = graph,
                                        mode = "out") == 0]
  
  visited <- c(bfs_result$order[!name %in% unique(end_nodes)$name],
               unique(end_nodes))
  
  vertex_attr(graph, "split", visited$name) <- 
    unname(map_lgl(visited, is_split, graph = graph))
  
  vertex_attr(graph, "combined", visited$name) <- 
    unname(map_lgl(.x = visited, 
                   .f = is_combined, 
                   graph = graph, 
                   compare_node = node))
  
  vertex_attr(graph, "nextNodes", visited$name) <-
    map(visited, neighbors, graph = graph, mode = "out")
  
  visited <- V(graph)[visited$name]
  
  return(visited)
  
}

